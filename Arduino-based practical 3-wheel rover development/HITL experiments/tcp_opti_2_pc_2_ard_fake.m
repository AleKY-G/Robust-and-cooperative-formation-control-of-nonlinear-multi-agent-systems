
%% Step 0.1: Basic settings
clear;
clc;
step_size = 20;                        % Control step size in milliseconds
num_agent = 3;                          % Number of agents
dimension = 3;                          % Dimension of system states
% Radius of the rover
rover_R = [0.13,0.13,0.13];   
% Radius of the wheels
wheel_R = [0.05,0.05,0.05];        
% Motor max speed (step/s)
motor_max_speed = [3000,3000,3000];     
% motor step size (switch)
step_size_motor = [1/4,1/4,1/4];
% gearbox amplifier constant
gear_constant = [5.18,5.18,5.18];       
% Saturation limitation in m/s
satu_limit = 0.2 * ones(size(motor_max_speed));

% TCP IP address for each rover
% rover_ip = ['172.20.10.11';'172.20.10.12';'172.20.10.13'];
rover_ip = ['129.127.29.11';'129.127.29.22';'129.127.29.33'];

%% Step 0.2: Set up opti-track
opti = opti_class;
opti.opti_set_up();

%% Step 0.3: Set up the role of PC (to each agent)
pc = pc_class;
rov = struct();
rov.L_sub = '';
rov.tcp_port = [];
rov.x_i = [0;0;0];
rov.x_di = [0;0;0];
rov.v_di = [0;0;0];
rov.delta_xi = [0;0;0];
rov.serial_num = 0;
rov.x_hat_i = [0;0;0];
rov.w_hat_i = [0;0;0];
rov.u_hat_i = [0;0;0];
rov.xi_i = [0;0;0];
rov.g_i = zeros(3,3);
rov.u_i = [0;0;0];
rov_info = [rov; rov; rov];

%% Step 1: Wireless communication construction

for i = 1 : num_agent
    % UDP communication
    pc.udp_communication(rover_ip(i,:), step_size);
    pause(1);
    % TCP communication
    r = rover_class;
    r.open_port();
    rov_info(i).tcp_port = r.tcp_port;
    r.askID();
    rov_info(i).serial_num = r.id;
    % Distribute the topology information for the agents
    pause(2);
end

fprintf("Communication construction is completed.\n");

%% Step 2: Real-time networked control
%% Step 2.1: Some basic initialisation
pause(3);
stop_time = 90;     % Task time (second)

Laplacian = [1,-1,0;
             0,1,-1;
             -1,0,1];
         
% Laplacian = 1;

% Laplacian = [1,-1;
%             -1,1];

B = 0.8 * eye(num_agent);

L = Laplacian + B;

% Step 2.2: Data matrix initialisation
% Matrix initialisation
time_matrix = zeros(stop_time/step_size*1000+1,1);

% Agent position read from Opti-track
agent_pos = zeros(stop_time/step_size*1000+1, num_agent * dimension);
current_agent_pos = zeros(num_agent * dimension, 1);      % Column vector

% Reference generated by the PC
pos_ref = zeros(stop_time/step_size*1000+1, num_agent * dimension);
vel_ref = zeros(stop_time/step_size*1000+1, num_agent * dimension);
current_pos_ref = zeros(num_agent * dimension, 1);      % Column vector
current_vel_ref = zeros(num_agent * dimension, 1);      % Column vector

% Position tracking error calculated by the PC
delta_x = zeros(stop_time/step_size*1000+1, num_agent * dimension);
e_x = zeros(stop_time/step_size*1000+1, num_agent * dimension);
current_delta_x = zeros(num_agent * dimension, 1);      % Column vector
current_e_x = zeros(num_agent * dimension, 1);      % Column vector

% Observer states
w_hat = zeros(stop_time/step_size*1000+1, num_agent * dimension);
x_hat = zeros(stop_time/step_size*1000+1, num_agent * dimension);
u_hat = zeros(stop_time/step_size*1000+1, num_agent * dimension);

% Auxiliary variable
xi = zeros(stop_time/step_size*1000+1, num_agent * dimension);
xi_prev = zeros(num_agent * dimension,1);

% Control input calculated by the PC (only for networked control structure)
agent_control = zeros(stop_time/step_size*1000+1, num_agent * dimension);
motor_speed = zeros(stop_time/step_size*1000+1, num_agent * dimension);
current_agent_control = zeros(num_agent * dimension, 1);      % Column vector
current_motor_speed = zeros(num_agent * dimension, 1);      % Column vector

% Record the initial time
timer = clock;
ini_time = (timer(4) * 3600 + timer(5) * 60 + timer(6)) * 1000;

% Record the calculation time
agent_sta_time = zeros(stop_time/step_size*1000+1, num_agent);
agent_end_time = zeros(stop_time/step_size*1000+1, num_agent);

% Now we entre the big loop
int_num = 0;           % The number of control iteration

% Step 2.3: Begin the big real-time control loop
while 1
    
    % Step 2.3.1: Record the current time
    timer = clock;
    cur_time = (timer(4) * 3600 + timer(5) * 60 + timer(6)) * 1000;
    now_time = cur_time - ini_time;  % Unit: ms
    
    % Step 2.3.2: If the time is triggered
    if now_time >= step_size * int_num
        
        % Step 2.3.2.1: Reference generation and position reading
        for i = 1 : num_agent
            % Record start time
            timer = clock;
            start_time = (timer(4) * 3600 + timer(5) * 60 + timer(6)) * 1000 - ini_time;
            
            % Generate reference
            [rov_info(i).x_di, rov_info(i).v_di] = pc.reference_generator(now_time/1000, i);
            
            % Read current position from opti-track
            rov_info(i).x_i = opti.opti_get_pos(i);
            if int_num == 0
                rov_info(i).x_hat_i = rov_info(i).x_i;
            end
            rov_info(i).delta_xi = rov_info(i).x_i - rov_info(i).x_di;
            
            % Temporary storage
            current_pos_ref((i-1) * dimension + 1 : i * dimension) = rov_info(i).x_di;
            current_vel_ref((i-1) * dimension + 1 : i * dimension) = rov_info(i).v_di;
            current_agent_pos((i-1) * dimension + 1 : i * dimension) = rov_info(i).x_i;
            current_delta_x((i-1) * dimension + 1 : i * dimension) = rov_info(i).delta_xi;
            
        end
        
        % Step 2.3.2.2: Fictitious communication
        current_e_x = kron(L, eye(3)) * current_delta_x;
        
        % Step 2.3.2.3: Motion control
        for i = 1 : num_agent
            
            % Uncertainty observation
            rov_info(i) = pc.uncertainty_observer(step_size/1000, rover_R(i), rov_info(i));
            
            % Adaptive controller
            rov_info(i) = pc.controller(step_size/1000, satu_limit(i), rover_R(i), current_e_x((i-1)*dimension+1:i*dimension) , rov_info(i));
%             m_speed = pc.motor_speed(u_i, gear_constant(i), wheel_R(i), step_size_motor(i));
            
            % PC to rover communication
            r.sendreference(rov_info(i).u_i, rov_info(i).tcp_port);     % With cal (Ard)
    
            % Data recording         
            agent_control(int_num+1, (i-1) * dimension + 1 : i * dimension) = rov_info(i).u_i';
            xi(int_num+1, (i-1) * dimension + 1 : i * dimension) = rov_info(i).xi_i';
            x_hat(int_num+1, (i-1) * dimension + 1 : i * dimension) = rov_info(i).x_hat_i';
            w_hat(int_num+1, (i-1) * dimension + 1 : i * dimension) = rov_info(i).w_hat_i';
            u_hat(int_num+1, (i-1) * dimension + 1 : i * dimension) = rov_info(i).u_hat_i';
%             motor_speed(int_num+1, (i-1) * dimension + 1 : i * dimension) = m_speed';
            
            % Record end time
            timer = clock;
            end_time = (timer(4) * 3600 + timer(5) * 60 + timer(6)) * 1000 - ini_time;
            
            agent_sta_time(int_num+1, i) = start_time;
            agent_end_time(int_num+1, i) = end_time;

        end
        
        pos_ref(int_num+1, :) = current_pos_ref';
        vel_ref(int_num+1, :) = current_vel_ref';
        agent_pos(int_num+1, :) = current_agent_pos';
        delta_x(int_num+1, :) = current_delta_x';
        e_x(int_num+1, :) = current_e_x';
        
        % Propagation recording
        int_num = int_num + 1;
        time_matrix(int_num) = now_time/1000;
    end
    
    if now_time > stop_time * 1000
        for i = 1 : num_agent
            r.sendreference(zeros(3,1), rov_info(i).tcp_port);
        end
        break;
    end
end


%% Stop all agents
for i = 1 : num_agent
    r.sendreference(zeros(3,1), rov_info(i).tcp_port);
end

%%